/*
 * Name: Michael Scholten
 * Date: February 6, 2022
 * Description: a simple usart client
 * Source: https://blog.mbedded.ninja/programming/operating-systems/linux/linux-serial-ports-using-c-cpp/
*/
// c standard
#include <stdio.h>   // fprintf, stderr, printf
#include <string.h>  // strerror
#include <stdlib.h>  // exit, EXIT_FAILURE
#include <stdbool.h> // bool, false, true
#include <signal.h>  // signal, SIGINT
#include <stdint.h>  // uint32_t
#include <time.h>    // CLOCKS_PER_SEC

// linux only
#include <fcntl.h>   // open, O_RDWR
#include <errno.h>   // errno
#include <termios.h> // POSIX terminal control definitions
#include <unistd.h>  // read, close, usleep

// easy settings
const char *PORT = "/dev/ttyACM0";
const uint32_t BAUDRATE = 9600;
#define BYTESIZE 8
#define READ true
#define WRITE false
const uint16_t BUFFER_SIZE = 1024;
const uint32_t DELAY_US = CLOCKS_PER_SEC / BAUDRATE * BYTESIZE;

volatile bool run;

// assures the program won't stop abruptly when user tries to close the program
void safetyHandler(int signum){
    run = false;
}

// functions for initializing termios, the serial
void termiosInit(int*, struct termios*);
void termios_openPort(int*);
void termios_retrieveSettings(int*, struct termios*);
void termios_setSettings(struct termios*);
void termios_storeSettings(int*, struct termios*);

int main(){
    // declare the serial port, termios settings, buffer, and the received messageLength
    int serialPort;
    struct termios tty = {0};
    char buffer[BUFFER_SIZE];
    int16_t messageLength;

    // set the safety handle
    signal(SIGINT, safetyHandler);

    // user doesn't have to press enter before entered data is read

    termiosInit(&serialPort, &tty);

    // set run to true, this will be set to false on exit
    run = true;
    
    while(run){
#if WRITE
        char c;
        uint16_t i = 0;
        while((c = getchar()) != '\n' && i < BUFFER_SIZE - 1) buffer[i++] = c;
        buffer[i] = '\0';
        write(serialPort, buffer, BUFFER_SIZE);
        while(c != '\n') c = getchar();
#endif
#if READ
        // read the received text
        messageLength = read(serialPort, buffer, BUFFER_SIZE);

        // throw an error if we failed to read the text
        if(messageLength < 0){
            fprintf(stderr, "ERROR %d from read: %s\n", errno, strerror(errno));
            break;
        }else if(messageLength > 0){
            // append a '\0' to the end of the text and show the text, if the received text was atleast 1 byte
            buffer[messageLength] = '\0';
            printf("%s", buffer);
        }
#endif
        // wait for some amount of time
        usleep(DELAY_US);
    }

    // close the serial port before exiting the program
    close(serialPort);
}

void termios_openPort(int *serialPort){
    /*
     * /dev/ttyACM0 : Arduino like devices
     * /dev/ttyPS0  : Xilinx Zynq FPGAs running on Yocto-based linux use this as default serial Getty port
     * /dev/ttyS0   : standard COM ports, not found on modern devices
     * /dev/ttyUSB0 : Most USB-to-serial cables
     * /dev/pts/0   : pseudo terminal generated by socat
    */
    // open for reading and writing
    *serialPort = open(PORT, O_RDWR);

    // throw an error if we failed to open the port
    if(*serialPort < 0){
        fprintf(stderr, "ERROR %d from open: %s\n", errno, strerror(errno));
        exit(EXIT_FAILURE);
    }
}

void termios_retrieveSettings(int *serialPort, struct termios *tty){
    // read exisiting settings and throw an error, if it failed.
    // POSIX states that the struct passed to tcsetattr must have been initialized with tcgetattr()
    // otherwise, behaviour is undefined.
    if(tcgetattr(*serialPort, tty)){
        fprintf(stderr, "ERROR %d from tcgetattr: %s\n", errno, strerror(errno));
        close(*serialPort);
        exit(EXIT_FAILURE);
    }
}

void termios_setSettings(struct termios *tty){
    // ~PARENB  : no parity bit
    // ~CSTOPB  : only one stop bit
    // ~CRTSCTS : disable hardware flow control
    // CS8      : 8 bits per byte
    // CLOCAL   : disable modem-specific signal lines and prevent controlling process from getting sent SIGHUP signal when modem disconnects
    // CREAD    : allows us to read data
#if BYTESIZE == 5
    tty->c_cflag = (tty->c_cflag & ~(PARENB | CSTOPB | CRTSCTS)) | CS5 | CLOCAL | CREAD;
#elif BYTESIZE == 6
    tty->c_cflag = (tty->c_cflag & ~(PARENB | CSTOPB | CRTSCTS)) | CS6 | CLOCAL | CREAD;
#elif BYTESIZE == 7
    tty->c_cflag = (tty->c_cflag & ~(PARENB | CSTOPB | CRTSCTS)) | CS7 | CLOCAL | CREAD;
#else
    tty->c_cflag = (tty->c_cflag & ~(PARENB | CSTOPB | CRTSCTS)) | CS8 | CLOCAL | CREAD;
#endif
    // ~ICANON : disable canonical mode, which waits for a new line and treats some characters like backspace specially, which may lead to missing bytes
    // ~ECHO   : disable echo
    // ~ECHOE  : disable erasure
    // ~ECHONL : disbale new-line echo
    // ~ISIG   : disable interpretation of INTR, QUIT, and SUSP chars
    tty->c_lflag &= ~(ICANON | ECHO | ECHOE | ECHONL);

    // ~(IXON | IXOFF | IXANY)                                      : turn off software flow control
    // ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL) : turn off special handling of bytes on receive
    tty->c_iflag &= ~(IXON | IXOFF | IXANY | IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);

    // ~OPOST : prevent special interpretation of output bytes
    // ~ONLCR : prevent conversion of newline to carriage return or line feed
    tty->c_oflag &= ~(OPOST | ONLCR);
    
    // VMIN = 0, VTIME = 0 : no blocking, return what is available
    // VMIN > 0, VTIME = 0 : read() always waits for VMIN chars, read() could block indefinitely
    // VMIN = 0, VTIME > 0 : read() waits for VTIME deciseconds or until any amount of data has been received
    // VMIN > 0, VTIME > 0 : read() waits until VMIN chars has been received or VTIME deciseconds after first char has been received
    // wait for 1 second, returning as soon as any data is received
    tty->c_cc[VTIME] = 0;
    tty->c_cc[VMIN] = 0;

    // standard baud rates: 0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800
    // set baud rate to 9600
    cfsetspeed(tty, BAUDRATE);
}

void termios_storeSettings(int *serialPort, struct termios *tty){
    // save the new settings, and throw an error if there were any
    if(tcsetattr(*serialPort, TCSANOW, tty)){
        fprintf(stderr, "ERROR %d from tcsetattr: %s\n", errno, strerror(errno));
        close(*serialPort);
        exit(EXIT_FAILURE);
    }
}

void termiosInit(int *serialPort, struct termios *tty){
    termios_openPort(serialPort);
    termios_retrieveSettings(serialPort, tty);
    termios_setSettings(tty);
    termios_storeSettings(serialPort, tty);
}
